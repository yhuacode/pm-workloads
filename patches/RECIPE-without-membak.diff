diff --git a/CMakeLists.txt b/CMakeLists.txt
index bce20d7..b1da758 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,3 +1,6 @@
+set(CMAKE_C_COMPILER "/home/vagrant/AFLplusplus/afl-clang-fast")
+set(CMAKE_CXX_COMPILER "/home/vagrant/AFLplusplus/afl-clang-fast++")
+
 cmake_minimum_required(VERSION 2.8)
 project(RECIPE)
 
@@ -8,7 +11,9 @@ else()
     message(STATUS "Build type is set to ${CMAKE_BUILD_TYPE}")
 endif()
 
-set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++17 -march=native -mrtm -mcx16 -mavx -mavx2 -mbmi2 -mlzcnt -Wno-deprecated-declarations -Wall -Wextra -fno-builtin-malloc -fno-builtin-calloc -fno-builtin-realloc -fno-builtin-free -faligned-new=64 -DNDEBUG")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++17 -march=native -mrtm -mcx16 -mavx -mavx2 -mbmi2 -mlzcnt -Wno-deprecated-declarations -Wall -Wextra -fno-builtin-malloc -fno-builtin-calloc -fno-builtin-realloc -fno-builtin-free -faligned-new=64 -DNDEBUG -fheinous-gnu-extensions")
+
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -march=native -mrtm -mcx16 -mavx -mavx2 -mbmi2 -mlzcnt -Wno-deprecated-declarations -Wall -Wextra -fno-builtin-malloc -fno-builtin-calloc -fno-builtin-realloc -fno-builtin-free -faligned-new=64 -DNDEBUG -fheinous-gnu-extensions")
 
 execute_process(COMMAND cat /proc/cpuinfo COMMAND grep clflush OUTPUT_VARIABLE ENABLE_CLFLUSH)
 execute_process(COMMAND cat /proc/cpuinfo COMMAND grep clflushopt OUTPUT_VARIABLE ENABLE_CLFLUSHOPT)
@@ -54,7 +59,6 @@ else()
 endif()
 
 if(ENABLE_AVX2 AND ENABLE_BMI2)
-    set(HOT TRUE)
 else()
     set(HOT FALSE)
     message(STATUS "Cannot find avx2 & bmi2 --> HOT (Height Optimized Trie) is disabled")
@@ -80,25 +84,32 @@ include_directories(P-HOT/libs/hot/commons/include P-HOT/libs/hot/rowex/include
     P-HOT/libs/idx/content-helpers/include P-HOT/libs/idx/utils/include P-HOT/libs/profile-lib/include)
 endif()
 
+set(PMDK_DIR "/home/vagrant/pmdk/install")
+if (NOT PMDK_DIR)
+    message(FATAL_ERROR "The environmantal variable 'PMDK_DIR' is required!")
+else()
+    message(STATUS "PMDK_DIR is set to ${PMDK_DIR}")
+endif()
+
 include_directories(third-party/CCEH)
 include_directories(P-Masstree)
 include_directories(P-CLHT/include P-CLHT/external/include)
 include_directories(P-BwTree)
+include_directories(include ${PMDK_DIR}/include)
 
 find_library(JemallocLib jemalloc)
 find_library(TbbLib tbb)
 find_package (Threads)
+link_directories(${PMDK_DIR}/lib/pmdk_debug)
 
 if (HOT)
 set(INDEX_FILES P-ART/Tree.cpp P-Masstree/masstree.cpp third-party/FAST_FAIR/btree.h
     P-HOT/libs/hot/rowex/include/hot/rowex/HOTRowex.hpp third-party/CCEH/src/CCEH_MSB.cpp
-    third-party/CCEH/src/Level_hashing.cpp P-BwTree/src/bwtree.cpp
-    third-party/WOART/woart.cpp P-CLHT/src/clht_lb_res.c P-CLHT/src/clht_gc.c
+    P-CLHT/src/clht_lb_res.c P-CLHT/src/clht_gc.c
     P-CLHT/external/sspfd/sspfd.c P-CLHT/external/ssmem/src/ssmem.c)
 else()
 set(INDEX_FILES P-ART/Tree.cpp third-party/FAST_FAIR/btree.h third-party/CCEH/src/CCEH_MSB.cpp
-    third-party/CCEH/src/Level_hashing.cpp P-BwTree/src/bwtree.cpp P-Masstree/masstree.cpp
-    P-BwTree/test/test_suite.cpp third-party/WOART/woart.cpp
+    P-Masstree/masstree.cpp
     P-CLHT/src/clht_lb_res.c P-CLHT/src/clht_gc.c P-CLHT/external/sspfd/sspfd.c
     P-CLHT/external/ssmem/src/ssmem.c)
 endif()
@@ -110,4 +121,4 @@ target_link_libraries(Indexes ${TbbLib} ${JemallocLib} ${CMAKE_THREAD_LIBS_INIT}
 set(YCSB_TEST ycsb.cpp)
 add_executable(ycsb ${YCSB_TEST})
 
-target_link_libraries(ycsb Indexes atomic boost_system boost_thread)
+target_link_libraries(ycsb Indexes atomic boost_system boost_thread pmemobj pmem)
diff --git a/P-CLHT/external/ssmem/src/ssmem.c b/P-CLHT/external/ssmem/src/ssmem.c
index 7378df4..ef01165 100644
--- a/P-CLHT/external/ssmem/src/ssmem.c
+++ b/P-CLHT/external/ssmem/src/ssmem.c
@@ -166,7 +166,7 @@ ssmem_list_node_new(void* mem, ssmem_list_t* next)
 /* 
  *
  */
-inline ssmem_released_t*
+ssmem_released_t*
 ssmem_released_node_new(void* mem, ssmem_released_t* next)
 {
   ssmem_released_t* rel;
diff --git a/P-CLHT/include/atomic_ops.h b/P-CLHT/include/atomic_ops.h
index 6563315..b3b360f 100644
--- a/P-CLHT/include/atomic_ops.h
+++ b/P-CLHT/include/atomic_ops.h
@@ -225,11 +225,11 @@ uint8_t oldval;
 #define CAS_U32(a,b,c) __sync_val_compare_and_swap(a,b,c)
 #define CAS_U64(a,b,c) __sync_val_compare_and_swap(a,b,c)
 //Swap
-#define SWAP_PTR(a,b) swap_pointer(a,b)
-#define SWAP_U8(a,b) swap_uint8(a,b)
-#define SWAP_U16(a,b) swap_uint16(a,b)
-#define SWAP_U32(a,b) swap_uint32(a,b)
-#define SWAP_U64(a,b) swap_uint64(a,b)
+#define SWAP_PTR(a,b) __atomic_exchange_n(a, b, __ATOMIC_SEQ_CST)
+#define SWAP_U8(a,b) __atomic_exchange_n(a, b, __ATOMIC_SEQ_CST)
+#define SWAP_U16(a,b) __atomic_exchange_n(a, b, __ATOMIC_SEQ_CST)
+#define SWAP_U32(a,b) __atomic_exchange_n(a, b, __ATOMIC_SEQ_CST)
+#define SWAP_U64(a,b) __atomic_exchange_n(a, b, __ATOMIC_SEQ_CST)
 //Fetch-and-increment
 #define FAI_U8(a) __sync_fetch_and_add(a,1)
 #define FAI_U16(a) __sync_fetch_and_add(a,1)
@@ -252,7 +252,7 @@ uint8_t oldval;
 #define DAF_U32(a) __sync_sub_and_fetch(a,1)
 #define DAF_U64(a) __sync_sub_and_fetch(a,1)
 //Test-and-set
-#define TAS_U8(a) tas_uint8(a)
+#define TAS_U8(a) __atomic_exchange_n(a, (uint8_t)0xFF, __ATOMIC_SEQ_CST)
 //Memory barrier
 #define MEM_BARRIER __sync_synchronize()
 //Relax CPU
diff --git a/P-CLHT/include/clht_lb_res.h b/P-CLHT/include/clht_lb_res.h
index 13df699..18bbf4c 100644
--- a/P-CLHT/include/clht_lb_res.h
+++ b/P-CLHT/include/clht_lb_res.h
@@ -31,6 +31,8 @@
 #ifndef _CLHT_RES_RES_H_
 #define _CLHT_RES_RES_H_
 
+#define pm_sync_var_hint(size, init_val) __attribute__((__annotate__("sync-" #size "-" #init_val)))
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <inttypes.h>
@@ -159,7 +161,7 @@ typedef volatile uint8_t clht_lock_t;
 
 typedef struct ALIGNED(CACHE_LINE_SIZE) bucket_s
 {
-  clht_lock_t lock;
+  clht_lock_t lock pm_sync_var_hint(1, 0);
   volatile uint32_t hops;
   clht_addr_t key[ENTRIES_PER_BUCKET];
   clht_val_t val[ENTRIES_PER_BUCKET];
@@ -181,9 +183,9 @@ typedef struct ALIGNED(CACHE_LINE_SIZE) clht
       struct clht_hashtable_s* ht_oldest;
       struct ht_ts* version_list;
       size_t version_min;
-      volatile clht_lock_t resize_lock;
-      volatile clht_lock_t gc_lock;
-      volatile clht_lock_t status_lock;
+      volatile clht_lock_t resize_lock pm_sync_var_hint(1, 0);
+      volatile clht_lock_t gc_lock pm_sync_var_hint(1, 0);
+      volatile clht_lock_t status_lock pm_sync_var_hint(1, 0);
     };
     uint8_t padding[2 * CACHE_LINE_SIZE];
   };
@@ -458,10 +460,10 @@ POBJ_LAYOUT_TOID(clht, bucket_t);
 POBJ_LAYOUT_END(clht);
 
 // Global pool uuid
-uint64_t pool_uuid;
+extern uint64_t pool_uuid;
 
 // Global pool pointer
-PMEMobjpool *pop;
+extern PMEMobjpool *pop;
 
 // pmemobj header size (presume using default compact header)
 #define POBJ_HEADER_SIZE        16
diff --git a/P-CLHT/src/clht_lb_res.c b/P-CLHT/src/clht_lb_res.c
index 7411f12..17aa5a3 100644
--- a/P-CLHT/src/clht_lb_res.c
+++ b/P-CLHT/src/clht_lb_res.c
@@ -1,4 +1,4 @@
-/*   
+/*
  *   File: clht_lb_res.c
  *   Author: Vasileios Trigonakis <vasileios.trigonakis@epfl.ch>
  *   Description: lock-based cache-line hash table with resizing.
@@ -35,6 +35,8 @@
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <emmintrin.h>
+#include <x86intrin.h>  // clwb
+#include <xmmintrin.h>  // sfence
 
 #include "clht_lb_res.h"
 
@@ -50,6 +52,13 @@ __thread uint32_t put_num_failed_on_new = 0;
 
 __thread size_t check_ht_status_steps = CLHT_STATUS_INVOK_IN;
 
+// Global pool uuid
+uint64_t pool_uuid;
+
+// Global pool pointer
+PMEMobjpool *pop;
+
+
 #include "stdlib.h"
 #include "assert.h"
 
@@ -67,7 +76,7 @@ clht_type_desc()
 }
 
     inline int
-is_power_of_two (unsigned int x) 
+is_power_of_two (unsigned int x)
 {
     return ((x != 0) && !(x & (x - 1)));
 }
@@ -108,7 +117,8 @@ inline void *clht_ptr_from_off(uint64_t offset, bool alignment)
 }
 
 static inline void mfence() {
-    asm volatile("sfence":::"memory");
+    // asm volatile("sfence":::"memory");
+    _mm_sfence();
 }
 
 static inline void clflush(char *data, int len, bool front, bool back)
@@ -118,11 +128,14 @@ static inline void clflush(char *data, int len, bool front, bool back)
         mfence();
     for(; ptr<data+len; ptr+=CACHE_LINE_SIZE){
 #ifdef CLFLUSH
-        asm volatile("clflush %0" : "+m" (*(volatile char *)ptr));
+        // asm volatile("clflush %0" : "+m" (*(volatile char *)ptr));
+        _mm_clflush((volatile char *)ptr);
 #elif CLFLUSH_OPT
-        asm volatile(".byte 0x66; clflush %0" : "+m" (*(volatile char *)(ptr)));
+        // asm volatile(".byte 0x66; clflush %0" : "+m" (*(volatile char *)(ptr)));
+        _mm_clflushopt((volatile char *)ptr);
 #elif CLWB
-        asm volatile(".byte 0x66; xsaveopt %0" : "+m" (*(volatile char *)(ptr)));
+        // asm volatile(".byte 0x66; xsaveopt %0" : "+m" (*(volatile char *)(ptr)));
+        _mm_clwb((volatile char *)ptr);
 #endif
     }
     if (back)
@@ -185,7 +198,7 @@ static int bucket_init(PMEMobjpool *pop_arg, void *ptr, void *arg)
 
 /* Create a new bucket. */
     bucket_t*
-clht_bucket_create() 
+clht_bucket_create()
 {
     bucket_t* bucket = NULL;
     PMEMoid bucket_oid;
@@ -207,6 +220,7 @@ clht_bucket_create_stats(clht_hashtable_t* h, int* resize)
     if (((uint64_t)b & (CACHE_LINE_SIZE - 1)) != 0)
         fprintf(stderr, "cacheline-unaligned bucket allocation\n");
 
+    printf("clht_bucket_create_stats (%u ~ %u)\n", h->num_expands, h->num_expands_threshold);
     //if (IAF_U32(&h->num_expands) == h->num_expands_threshold)
     if (IAF_U32(&h->num_expands) >= h->num_expands_threshold)
     {
@@ -218,7 +232,7 @@ clht_bucket_create_stats(clht_hashtable_t* h, int* resize)
 
 clht_hashtable_t* clht_hashtable_create(uint64_t num_buckets);
 
-    clht_t* 
+    clht_t*
 clht_create(uint64_t num_buckets)
 {
     // Enable prefault
@@ -229,11 +243,13 @@ clht_create(uint64_t num_buckets)
         perror("failed to configure prefaults at create\n");
 
     // Open the PMEMpool if it exists, otherwise create it
-    size_t pool_size = 32*1024*1024*1024UL;
-    if (access("/dev/shm/pool", F_OK) != -1)
-        pop = pmemobj_open("/dev/shm/pool", POBJ_LAYOUT_NAME(clht));
+    __AFL_INIT();
+    remove(getenv("PMEM_POOL"));
+    const size_t pool_size = 32 * 1024 * 1024UL, pool_hdr_size = 0x1000UL;
+    if (access(getenv("PMEM_POOL"), F_OK) != -1)
+        pop = pmemobj_open(getenv("PMEM_POOL"), POBJ_LAYOUT_NAME(clht));
     else
-        pop = pmemobj_create("/dev/shm/pool", POBJ_LAYOUT_NAME(clht), pool_size, 0666);
+        pop = pmemobj_create(getenv("PMEM_POOL"), POBJ_LAYOUT_NAME(clht), pool_size, 0666);
 
     if (pop == NULL)
         perror("failed to open the pool\n");
@@ -269,6 +285,14 @@ clht_create(uint64_t num_buckets)
         w->resize_lock = LOCK_FREE;
         w->gc_lock = LOCK_FREE;
         w->status_lock = LOCK_FREE;
+        clht_hashtable_t *h = clht_ptr_from_off(w->ht_off, false);
+        bucket_t *bucket_ptr = clht_ptr_from_off(h->table_off, true);
+        uint64_t i;
+        printf("num_buckets: %u\n", h->num_buckets);
+        for (i = 0; i < h->num_buckets; i++) {
+            bucket_ptr[i].lock = LOCK_FREE;
+        }
+        w->version_list = NULL;
     }
 
     return w;
@@ -342,7 +366,7 @@ clht_hashtable_create(uint64_t num_buckets)
 
 /* Hash a key for a particular hash table. */
     uint64_t
-clht_hash(clht_hashtable_t* hashtable, clht_addr_t key) 
+clht_hash(clht_hashtable_t* hashtable, clht_addr_t key)
 {
     /* uint64_t hashval; */
     /* return __ac_Jenkins_hash_64(key) & (hashtable->hash); */
@@ -395,7 +419,7 @@ retry:
 bucket_exists(volatile bucket_t* bucket, clht_addr_t key)
 {
     uint32_t j;
-    do 
+    do
     {
         for (j = 0; j < ENTRIES_PER_BUCKET; j++)
         {
@@ -405,7 +429,7 @@ bucket_exists(volatile bucket_t* bucket, clht_addr_t key)
             }
         }
         bucket = (bucket_t *)clht_ptr_from_off(bucket->next_off, true);
-    } 
+    }
     while (unlikely(bucket != NULL));
     return false;
 }
@@ -441,11 +465,11 @@ clht_put(clht_t* h, clht_addr_t key, clht_val_t val)
     clht_val_t* empty_v = NULL;
 
     uint32_t j;
-    do 
+    do
     {
         for (j = 0; j < ENTRIES_PER_BUCKET; j++)
         {
-            if (bucket->key[j] == key) 
+            if (bucket->key[j] == key)
             {
                 LOCK_RLS(lock);
                 return false;
@@ -495,7 +519,7 @@ clht_put(clht_t* h, clht_addr_t key, clht_val_t val)
                 /* ht_resize_pes(h, 1); */
 				DEBUG_PRINT("Calling ht_status for key %ld\n", (long)key);
                 int ret = ht_status(h, 1, 0);
-				
+
 				// if crash, return true, because the insert anyway succeeded
 				if (ret == 0)
 					return true;
@@ -536,7 +560,7 @@ clht_update(clht_t* h, clht_addr_t key, clht_val_t val)
     CLHT_CHECK_STATUS(h);
 
     uint32_t j;
-    do 
+    do
     {
         for (j = 0; j < ENTRIES_PER_BUCKET; j++)
         {
@@ -548,9 +572,12 @@ clht_update(clht_t* h, clht_addr_t key, clht_val_t val)
             }
         }
         bucket = (bucket_t *)clht_ptr_from_off(bucket->next_off, true);
-    } 
+    }
     while (unlikely(bucket != NULL));
 
+    // Bugfix: Releasing the lock is required.
+    LOCK_RLS(lock);
+
     return false;
 }
 
@@ -780,12 +807,14 @@ ht_resize_pes(clht_t* h, int is_increase, int by)
     clflush_new_hashtable((bucket_t *)clht_ptr_from_off(ht_new->table_off, true), num_buckets_new);
     mfence();
 
+    printf("resize to %lu buckets from %lu\n", num_buckets_new, ht_old->num_buckets);
+
 	// atomically swap the root pointer
     // Presume the head of "h" contains the pointer (offset) to the hash table
     SWAP_U64((uint64_t*) h, (uint64_t) pmemobj_oid(ht_new).off);
     clflush((char *)h, sizeof(uint64_t), false, true);
 
-	DEBUG_PRINT("Parent reached correctly\n"); 
+	DEBUG_PRINT("Parent reached correctly\n");
     ht_old->table_new = ht_new;
     TRYLOCK_RLS(h->resize_lock);
 
@@ -1019,7 +1048,7 @@ void clht_lock_initialization(clht_t *h)
     bucket_t *buckets = (bucket_t *)clht_ptr_from_off(ht->table_off, true);
     for (i = 0; i < ht->num_buckets; i++) {
         buckets[i].lock = LOCK_FREE;
-        for (next = clht_ptr_from_off(buckets[i].next_off, true); 
+        for (next = clht_ptr_from_off(buckets[i].next_off, true);
                 next != NULL; next = clht_ptr_from_off(next->next_off, true)) {
             next->lock = LOCK_FREE;
         }
diff --git a/ycsb.cpp b/ycsb.cpp
index 179de6d..fbf2218 100644
--- a/ycsb.cpp
+++ b/ycsb.cpp
@@ -4,30 +4,51 @@
 #include <cstring>
 #include <vector>
 #include <fstream>
-#include <iostream>
+#include <stdio.h>
+#include <sstream>
 #include <stdlib.h>
 #include "tbb/tbb.h"
 
+#include <algorithm>
+#include <array>
+#include <atomic>
+#include <cassert>
+#include <chrono>
+#include <thread>
+#include <unordered_set>
+#include <cstddef>
+#include <vector>
+#include <mutex>
+#include <sys/types.h>
+#include <sys/wait.h>
+
 using namespace std;
 
 #include "P-ART/Tree.h"
-#include "third-party/FAST_FAIR/btree.h"
 #include "third-party/CCEH/src/Level_hashing.h"
 #include "third-party/CCEH/src/CCEH.h"
 #include "third-party/WOART/woart.h"
 #include "masstree.h"
-#include "P-BwTree/src/bwtree.h"
-#include "clht.h"
+#include "clht_lb_res.h"
 #include "ssmem.h"
 
+#ifndef __AFL_FUZZ_TESTCASE_LEN
+  ssize_t fuzz_len;
+  #define __AFL_FUZZ_TESTCASE_LEN fuzz_len
+  unsigned char fuzz_buf[1024000];
+  #define __AFL_FUZZ_TESTCASE_BUF fuzz_buf
+  #define __AFL_FUZZ_INIT() void sync()
+  #define __AFL_INIT() ((fuzz_len = read(0, fuzz_buf, sizeof(fuzz_buf))) > 0 ? 1 : 0)
+#endif
+
+__AFL_FUZZ_INIT();
+
 #ifdef HOT
 #include <hot/rowex/HOTRowex.hpp>
 #include <idx/contenthelpers/IdentityKeyExtractor.hpp>
 #include <idx/contenthelpers/OptionalValue.hpp>
 #endif
 
-using namespace wangziqi2013::bwtree;
-
 // index types
 enum {
     TYPE_ART,
@@ -224,800 +245,23 @@ void barrier_cross(barrier_t *b) {
 barrier_t barrier;
 /////////////////////////////////////////////////////////////////////////////////
 
-static uint64_t LOAD_SIZE = 64000000;
-static uint64_t RUN_SIZE = 64000000;
-
 void loadKey(TID tid, Key &key) {
     return ;
 }
 
-void ycsb_load_run_string(int index_type, int wl, int kt, int ap, int num_thread,
-        std::vector<Key *> &init_keys,
-        std::vector<Key *> &keys,
-        std::vector<int> &ranges,
-        std::vector<int> &ops)
-{
-    std::string init_file;
-    std::string txn_file;
-
-    if (ap == UNIFORM) {
-        if (kt == STRING_KEY && wl == WORKLOAD_A) {
-            init_file = "./index-microbench/workloads/ycsbkey_load_workloada";
-            txn_file = "./index-microbench/workloads/ycsbkey_run_workloada";
-        } else if (kt == STRING_KEY && wl == WORKLOAD_B) {
-            init_file = "./index-microbench/workloads/ycsbkey_load_workloadb";
-            txn_file = "./index-microbench/workloads/ycsbkey_run_workloadb";
-        } else if (kt == STRING_KEY && wl == WORKLOAD_C) {
-            init_file = "./index-microbench/workloads/ycsbkey_load_workloadc";
-            txn_file = "./index-microbench/workloads/ycsbkey_run_workloadc";
-        } else if (kt == STRING_KEY && wl == WORKLOAD_D) {
-            init_file = "./index-microbench/workloads/ycsbkey_load_workloadd";
-            txn_file = "./index-microbench/workloads/ycsbkey_run_workloadd";
-        } else if (kt == STRING_KEY && wl == WORKLOAD_E) {
-            init_file = "./index-microbench/workloads/ycsbkey_load_workloade";
-            txn_file = "./index-microbench/workloads/ycsbkey_run_workloade";
-        }
-    } else {
-        if (kt == STRING_KEY && wl == WORKLOAD_A) {
-            init_file = "./index-microbench/workloads/ycsbkey_load_workloada";
-            txn_file = "./index-microbench/workloads/ycsbkey_run_workloada";
-        } else if (kt == STRING_KEY && wl == WORKLOAD_B) {
-            init_file = "./index-microbench/workloads/ycsbkey_load_workloadb";
-            txn_file = "./index-microbench/workloads/ycsbkey_run_workloadb";
-        } else if (kt == STRING_KEY && wl == WORKLOAD_C) {
-            init_file = "./index-microbench/workloads/ycsbkey_load_workloadc";
-            txn_file = "./index-microbench/workloads/ycsbkey_run_workloadc";
-        } else if (kt == STRING_KEY && wl == WORKLOAD_D) {
-            init_file = "./index-microbench/workloads/ycsbkey_load_workloadd";
-            txn_file = "./index-microbench/workloads/ycsbkey_run_workloadd";
-        } else if (kt == STRING_KEY && wl == WORKLOAD_E) {
-            init_file = "./index-microbench/workloads/ycsbkey_load_workloade";
-            txn_file = "./index-microbench/workloads/ycsbkey_run_workloade";
-        }
-    }
-
-    std::ifstream infile_load(init_file);
-
-    std::string op;
-    std::string key;
-    int range;
-
-    std::string insert("INSERT");
-    std::string update("UPDATE");
-    std::string read("READ");
-    std::string scan("SCAN");
-    std::string maxKey("z");
-
-    int count = 0;
-    uint64_t val;
-    while ((count < LOAD_SIZE) && infile_load.good()) {
-        infile_load >> op >> key;
-        if (op.compare(insert) != 0) {
-            std::cout << "READING LOAD FILE FAIL!\n";
-            return ;
-        }
-        val = std::stoul(key.substr(4, key.size()));
-        init_keys.push_back(init_keys[count]->make_leaf((char *)key.c_str(), key.size()+1, val));
-        count++;
-    }
-
-    fprintf(stderr, "Loaded %d keys\n", count);
-
-    std::ifstream infile_txn(txn_file);
-
-    count = 0;
-    while ((count < RUN_SIZE) && infile_txn.good()) {
-        infile_txn >> op >> key;
-        if (op.compare(insert) == 0) {
-            ops.push_back(OP_INSERT);
-            val = std::stoul(key.substr(4, key.size()));
-            keys.push_back(keys[count]->make_leaf((char *)key.c_str(), key.size()+1, val));
-            ranges.push_back(1);
-        } else if (op.compare(update) == 0) {
-            ops.push_back(OP_UPDATE);
-            val = std::stoul(key.substr(4, key.size()));
-            keys.push_back(keys[count]->make_leaf((char *)key.c_str(), key.size()+1, val));
-            ranges.push_back(1);
-        } else if (op.compare(read) == 0) {
-            ops.push_back(OP_READ);
-            val = std::stoul(key.substr(4, key.size()));
-            keys.push_back(keys[count]->make_leaf((char *)key.c_str(), key.size()+1, val));
-            ranges.push_back(1);
-        } else if (op.compare(scan) == 0) {
-            infile_txn >> range;
-            ops.push_back(OP_SCAN);
-            keys.push_back(keys[count]->make_leaf((char *)key.c_str(), key.size()+1, 0));
-            ranges.push_back(range);
-        } else {
-            std::cout << "UNRECOGNIZED CMD!\n";
-            return;
-        }
-        count++;
-    }
+void ycsb_load_run_randint(int index_type, int num_thread) {
+    unsigned char *afl_testcase_buf;
+    int afl_testcase_len;
+    std::vector<std::istringstream> cmd_streams;
+    char *tok = NULL;
+    int i;
 
     if (index_type == TYPE_ART) {
-        ART_ROWEX::Tree tree(loadKey);
-
-        {
-            // Load
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, LOAD_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                auto t = tree.getThreadInfo();
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    Key *key = key->make_leaf((char *)init_keys[i]->fkey, init_keys[i]->key_len, init_keys[i]->value);
-                    tree.insert(key, t);
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: load, %f ,ops/us\n", (LOAD_SIZE * 1.0) / duration.count());
-        }
-
-        {
-            // Run
-            Key *end = end->make_leaf((char *)maxKey.c_str(), maxKey.size()+1, 0);
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, RUN_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                auto t = tree.getThreadInfo();
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    Key *key;
-                    if (ops[i] == OP_INSERT) {
-                        key = key->make_leaf((char *)keys[i]->fkey, keys[i]->key_len, keys[i]->value);
-                        tree.insert(key, t);
-                    } else if (ops[i] == OP_READ) {
-                        key = key->make_leaf((char *)keys[i]->fkey, keys[i]->key_len, keys[i]->value);
-                        Key *val = reinterpret_cast<Key *>(tree.lookup(key, t));
-                        if (val->value != keys[i]->value) {
-                            std::cout << "[ART] wrong key read: " << val->value << " expected:" << keys[i]->value << std::endl;
-                            throw;
-                        }
-                    } else if (ops[i] == OP_SCAN) {
-                        Key *results[200];
-                        Key *continueKey = NULL;
-                        size_t resultsFound = 0;
-                        size_t resultsSize = ranges[i];
-                        Key *start = start->make_leaf((char *)keys[i]->fkey, keys[i]->key_len, keys[i]->value);
-                        tree.lookupRange(start, end, continueKey, results, resultsSize, resultsFound, t);
-                    } else if (ops[i] == OP_UPDATE) {
-                        std::cout << "NOT SUPPORTED CMD!\n";
-                        exit(0);
-                    }
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: run, %f ,ops/us\n", (RUN_SIZE * 1.0) / duration.count());
-        }
-#ifdef HOT
-    } else if (index_type == TYPE_HOT) {
-        hot::rowex::HOTRowex<Key *, KeyExtractor> mTrie;
-
-        {
-            // Load
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, LOAD_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    Key *key = key->make_leaf((char *)init_keys[i]->fkey, init_keys[i]->key_len, init_keys[i]->value);
-                    Dummy::clflush((char *)key, sizeof(Key) + key->key_len, true, true);
-                    if (!(mTrie.insert(key))) {
-                        fprintf(stderr, "[HOT] load insert fail\n");
-                        exit(1);
-                    }
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: load, %f ,ops/us\n", (LOAD_SIZE * 1.0) / duration.count());
-        }
-
-        {
-            // Run
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, RUN_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    if (ops[i] == OP_INSERT) {
-                        Key *key = key->make_leaf((char *)keys[i]->fkey, keys[i]->key_len, keys[i]->value);
-                        Dummy::clflush((char *)key, sizeof(Key) + key->key_len, true, true);
-                        if (!(mTrie.insert(key))) {
-                            fprintf(stderr, "[HOT] run insert fail\n");
-                            exit(1);
-                        }
-                    } else if (ops[i] == OP_READ) {
-                        idx::contenthelpers::OptionalValue<Key *> result = mTrie.lookup((char const *)keys[i]->fkey);
-                        if (!result.mIsValid || result.mValue->value != keys[i]->value) {
-                            printf("mIsValid = %d\n", result.mIsValid);
-                            printf("Return value = %lu, Correct value = %lu\n", result.mValue->value, keys[i]->value);
-                            exit(1);
-                        }
-                    } else if (ops[i] == OP_SCAN) {
-                        idx::contenthelpers::OptionalValue<Key *> result = mTrie.scan((char const *)keys[i]->fkey, ranges[i]);
-                    } else if (ops[i] == OP_UPDATE) {
-                        std::cout << "NOT SUPPORTED CMD!\n";
-                        exit(0);
-                    }
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: run, %f ,ops/us\n", (RUN_SIZE * 1.0) / duration.count());
-        }
-#endif
-    } else if (index_type == TYPE_BWTREE) {
-        auto t = new BwTree<char *, uint64_t, KeyComparator, KeyEqualityChecker>{true, KeyComparator{1}, KeyEqualityChecker{1}};
-        t->UpdateThreadLocal(1);
-        t->AssignGCID(0);
-        std::atomic<int> next_thread_id;
-
-        {
-            // Load
-            auto starttime = std::chrono::system_clock::now();
-            next_thread_id.store(0);
-            t->UpdateThreadLocal(num_thread);
-            auto func = [&]() {
-                int thread_id = next_thread_id.fetch_add(1);
-                uint64_t start_key = LOAD_SIZE / num_thread * (uint64_t)thread_id;
-                uint64_t end_key = start_key + LOAD_SIZE / num_thread;
-
-                t->AssignGCID(thread_id);
-                for (uint64_t i = start_key; i < end_key; i++) {
-                    Dummy::clflush((char *)init_keys[i]->fkey, init_keys[i]->key_len, true, true);
-                    t->Insert((char *)init_keys[i]->fkey, init_keys[i]->value);
-                }
-                t->UnregisterThread(thread_id);
-            };
-
-            std::vector<std::thread> thread_group;
-
-            for (int i = 0; i < num_thread; i++)
-                thread_group.push_back(std::thread{func});
-
-            for (int i = 0; i < num_thread; i++)
-                thread_group[i].join();
-            t->UpdateThreadLocal(1);
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: load, %f ,ops/us\n", (LOAD_SIZE * 1.0) / duration.count());
-        }
-
-        {
-            // Run
-            auto starttime = std::chrono::system_clock::now();
-            next_thread_id.store(0);
-            t->UpdateThreadLocal(num_thread);
-            auto func = [&]() {
-                std::vector<uint64_t> v{};
-                v.reserve(1);
-                int thread_id = next_thread_id.fetch_add(1);
-                uint64_t start_key = RUN_SIZE / num_thread * (uint64_t)thread_id;
-                uint64_t end_key = start_key + RUN_SIZE / num_thread;
-
-                t->AssignGCID(thread_id);
-                for (uint64_t i = start_key; i < end_key; i++) {
-                    if (ops[i] == OP_INSERT) {
-                        Dummy::clflush((char *)keys[i]->fkey, keys[i]->key_len, true, true);
-                        t->Insert((char *)keys[i]->fkey, keys[i]->value);
-                    } else if (ops[i] == OP_READ) {
-                        v.clear();
-                        t->GetValue((char *)keys[i]->fkey, v);
-                        if (v[0] != keys[i]->value) {
-                            std::cout << "[BWTREE] wrong key read: " << v[0] << " expected:" << keys[i]->value << std::endl;
-                        }
-                    } else if (ops[i] == OP_SCAN) {
-                        uint64_t buf[200];
-                        auto it = t->Begin((char *)keys[i]->fkey);
-
-                        int resultsFound = 0;
-                        while (it.IsEnd() != true && resultsFound != ranges[i]) {
-                            buf[resultsFound] = it->second;
-                            resultsFound++;
-                            it++;
-                        }
-                    } else if (ops[i] == OP_UPDATE) {
-                        std::cout << "NOT SUPPORTED CMD!\n";
-                        exit(0);
-                    }
-                }
-                t->UnregisterThread(thread_id);
-            };
-
-            std::vector<std::thread> thread_group;
-
-            for (int i = 0; i < num_thread; i++)
-                thread_group.push_back(std::thread{func});
-
-            for (int i = 0; i < num_thread; i++)
-                thread_group[i].join();
-            t->UpdateThreadLocal(1);
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: run, %f ,ops/us\n", (RUN_SIZE * 1.0) / duration.count());
-        }
-    } else if (index_type == TYPE_MASSTREE) {
-        masstree::masstree *tree = new masstree::masstree();
-
-        {
-            // Load
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, LOAD_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                auto t = tree->getThreadInfo();
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    tree->put((char *)init_keys[i]->fkey, init_keys[i]->value, t);
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: load, %f ,ops/us\n", (LOAD_SIZE * 1.0) / duration.count());
-        }
-
-        {
-            // Run
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, RUN_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                auto t = tree->getThreadInfo();
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    if (ops[i] == OP_INSERT) {
-                        tree->put((char *)keys[i]->fkey, keys[i]->value, t);
-                    } else if (ops[i] == OP_READ) {
-                        uint64_t *ret = reinterpret_cast<uint64_t *> (tree->get((char *)keys[i]->fkey, t));
-                        if (ap == UNIFORM && (uint64_t) ret != keys[i]->value) {
-                            printf("[MASS] search key = %lu, search value = %lu\n", keys[i]->value, ret);
-                            exit(1);
-                        }
-                    } else if (ops[i] == OP_SCAN) {
-                        int resultsFound;
-                        uint64_t results[200];
-                        resultsFound = tree->scan((char *)keys[i]->fkey, ranges[i], results, t);
-                    } else if (ops[i] == OP_DELETE) {
-                        tree->del((char *)keys[i]->fkey, t);
-                    } else if (ops[i] == OP_UPDATE) {
-                        tree->put((char *)keys[i]->fkey, keys[i]->value, t);
-                    }
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: run, %f ,ops/us\n", (RUN_SIZE * 1.0) / duration.count());
-        }
-    } else if (index_type == TYPE_FASTFAIR) {
-        fastfair::btree *bt = new fastfair::btree();
-
-        {
-            // Load
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, LOAD_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    bt->btree_insert((char *)init_keys[i]->fkey, (char *) &init_keys[i]->value);
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: load, %f ,ops/us\n", (LOAD_SIZE * 1.0) / duration.count());
-        }
-
-        {
-            // Run
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, RUN_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    if (ops[i] == OP_INSERT) {
-                        bt->btree_insert((char *)keys[i]->fkey, (char *) &keys[i]->value);
-                    } else if (ops[i] == OP_READ) {
-                        uint64_t *ret = reinterpret_cast<uint64_t *> (bt->btree_search((char *)keys[i]->fkey));
-                        if (ret == NULL) {
-                            //printf("Return value is NULL\n");
-                        }else if (*ret != keys[i]->value) {
-                            //printf("[FASTFAIR] wrong value was returned: originally expected %lu\n", keys[i]->value);
-                            //exit(1);
-                        }
-                    } else if (ops[i] == OP_SCAN) {
-                        uint64_t buf[200];
-                        int resultsFound = 0;
-                        bt->btree_search_range ((char *)keys[i]->fkey, (char *)maxKey.c_str(), buf, ranges[i], resultsFound);
-                    } else if (ops[i] == OP_UPDATE) {
-                        std::cout << "NOT SUPPORTED CMD!\n";
-                        exit(0);
-                    }
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: run, %f ,ops/us\n", (RUN_SIZE * 1.0) / duration.count());
-        }
-    } else if (index_type == TYPE_WOART) {
-#ifdef STRING_TYPE
-        woart_tree *t = (woart_tree *)malloc(sizeof(woart_tree));
-        woart_tree_init(t);
-
-        {
-            // Load
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, LOAD_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    woart_insert(t, init_keys[i]->fkey, init_keys[i]->key_len, &init_keys[i]->value);
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: load, %f ,ops/us\n", (LOAD_SIZE * 1.0) / duration.count());
-        }
-
-        {
-            // Run
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, RUN_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    if (ops[i] == OP_INSERT) {
-                        woart_insert(t, keys[i]->fkey, keys[i]->key_len, &keys[i]->value);
-                    } else if (ops[i] == OP_READ) {
-                        uint64_t *ret = reinterpret_cast<uint64_t *> (woart_search(t, keys[i]->fkey, keys[i]->key_len));
-                        if (*ret != keys[i]->value) {
-                            printf("[WOART] search key = %lu, search value = %lu\n", keys[i]->value, *ret);
-                            exit(1);
-                        }
-                    } else if (ops[i] == OP_SCAN) {
-                        unsigned long buf[200];
-                        woart_scan(t, keys[i]->fkey, keys[i]->key_len, ranges[i], buf);
-                    } else if (ops[i] == OP_UPDATE) {
-                        std::cout << "NOT SUPPORTED CMD!\n";
-                        exit(0);
-                    }
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: run, %f ,ops/us\n", (RUN_SIZE * 1.0) / duration.count());
-        }
-#endif
-    }
-}
-
-void ycsb_load_run_randint(int index_type, int wl, int kt, int ap, int num_thread,
-        std::vector<uint64_t> &init_keys,
-        std::vector<uint64_t> &keys,
-        std::vector<int> &ranges,
-        std::vector<int> &ops)
-{
-    std::string init_file;
-    std::string txn_file;
-
-    if (ap == UNIFORM) {
-        if (kt == RANDINT_KEY && wl == WORKLOAD_A) {
-            init_file = "./index-microbench/workloads/loada_unif_int.dat";
-            txn_file = "./index-microbench/workloads/txnsa_unif_int.dat";
-        } else if (kt == RANDINT_KEY && wl == WORKLOAD_B) {
-            init_file = "./index-microbench/workloads/loadb_unif_int.dat";
-            txn_file = "./index-microbench/workloads/txnsb_unif_int.dat";
-        } else if (kt == RANDINT_KEY && wl == WORKLOAD_C) {
-            init_file = "./index-microbench/workloads/loadc_unif_int.dat";
-            txn_file = "./index-microbench/workloads/txnsc_unif_int.dat";
-        } else if (kt == RANDINT_KEY && wl == WORKLOAD_D) {
-            init_file = "./index-microbench/workloads/loadd_unif_int.dat";
-            txn_file = "./index-microbench/workloads/txnsd_unif_int.dat";
-        } else if (kt == RANDINT_KEY && wl == WORKLOAD_E) {
-            init_file = "./index-microbench/workloads/loade_unif_int.dat";
-            txn_file = "./index-microbench/workloads/txnse_unif_int.dat";
-        }
-    } else {
-        if (kt == RANDINT_KEY && wl == WORKLOAD_A) {
-            init_file = "./index-microbench/workloads/loada_unif_int.dat";
-            txn_file = "./index-microbench/workloads/txnsa_unif_int.dat";
-        } else if (kt == RANDINT_KEY && wl == WORKLOAD_B) {
-            init_file = "./index-microbench/workloads/loadb_unif_int.dat";
-            txn_file = "./index-microbench/workloads/txnsb_unif_int.dat";
-        } else if (kt == RANDINT_KEY && wl == WORKLOAD_C) {
-            init_file = "./index-microbench/workloads/loadc_unif_int.dat";
-            txn_file = "./index-microbench/workloads/txnsc_unif_int.dat";
-        } else if (kt == RANDINT_KEY && wl == WORKLOAD_D) {
-            init_file = "./index-microbench/workloads/loadd_unif_int.dat";
-            txn_file = "./index-microbench/workloads/txnsd_unif_int.dat";
-        } else if (kt == RANDINT_KEY && wl == WORKLOAD_E) {
-            init_file = "./index-microbench/workloads/loade_unif_int.dat";
-            txn_file = "./index-microbench/workloads/txnse_unif_int.dat";
-        }
-    }
-
-    std::ifstream infile_load(init_file);
-
-    std::string op;
-    uint64_t key;
-    int range;
-
-    std::string insert("INSERT");
-    std::string update("UPDATE");
-    std::string read("READ");
-    std::string scan("SCAN");
-
-    int count = 0;
-    while ((count < LOAD_SIZE) && infile_load.good()) {
-        infile_load >> op >> key;
-        if (op.compare(insert) != 0) {
-            std::cout << "READING LOAD FILE FAIL!\n";
-            return ;
-        }
-        init_keys.push_back(key);
-        count++;
-    }
-
-    fprintf(stderr, "Loaded %d keys\n", count);
-
-    std::ifstream infile_txn(txn_file);
-
-    count = 0;
-    while ((count < RUN_SIZE) && infile_txn.good()) {
-        infile_txn >> op >> key;
-        if (op.compare(insert) == 0) {
-            ops.push_back(OP_INSERT);
-            keys.push_back(key);
-            ranges.push_back(1);
-        } else if (op.compare(update) == 0) {
-            ops.push_back(OP_UPDATE);
-            keys.push_back(key);
-            ranges.push_back(1);
-        } else if (op.compare(read) == 0) {
-            ops.push_back(OP_READ);
-            keys.push_back(key);
-            ranges.push_back(1);
-        } else if (op.compare(scan) == 0) {
-            infile_txn >> range;
-            ops.push_back(OP_SCAN);
-            keys.push_back(key);
-            ranges.push_back(range);
-        } else {
-            std::cout << "UNRECOGNIZED CMD!\n";
-            return;
-        }
-        count++;
-    }
-
-    std::atomic<int> range_complete, range_incomplete;
-    range_complete.store(0);
-    range_incomplete.store(0);
-
-    if (index_type == TYPE_ART) {
-        ART_ROWEX::Tree tree(loadKey);
-
-        {
-            // Load
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, LOAD_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                auto t = tree.getThreadInfo();
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    Key *key = key->make_leaf(init_keys[i], sizeof(uint64_t), init_keys[i]);
-                    tree.insert(key, t);
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: load, %f ,ops/us\n", (LOAD_SIZE * 1.0) / duration.count());
-        }
-
-        {
-            // Run
-            Key *end = end->make_leaf(UINT64_MAX, sizeof(uint64_t), 0);
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, RUN_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                auto t = tree.getThreadInfo();
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    if (ops[i] == OP_INSERT) {
-                        Key *key = key->make_leaf(keys[i], sizeof(uint64_t), keys[i]);
-                        tree.insert(key, t);
-                    } else if (ops[i] == OP_READ) {
-                        Key *key = key->make_leaf(keys[i], sizeof(uint64_t), 0);
-                        uint64_t *val = reinterpret_cast<uint64_t *>(tree.lookup(key, t));
-                        if (*val != keys[i]) {
-                            std::cout << "[ART] wrong key read: " << val << " expected:" << keys[i] << std::endl;
-                            exit(1);
-                        }
-                    } else if (ops[i] == OP_SCAN) {
-                        Key *results[200];
-                        Key *continueKey = NULL;
-                        size_t resultsFound = 0;
-                        size_t resultsSize = ranges[i];
-                        Key *start = start->make_leaf(keys[i], sizeof(uint64_t), 0);
-                        tree.lookupRange(start, end, continueKey, results, resultsSize, resultsFound, t);
-                    } else if (ops[i] == OP_UPDATE) {
-                        std::cout << "NOT SUPPORTED CMD!\n";
-                        exit(0);
-                    }
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: run, %f ,ops/us\n", (RUN_SIZE * 1.0) / duration.count());
-        }
-#ifdef HOT
     } else if (index_type == TYPE_HOT) {
-        hot::rowex::HOTRowex<IntKeyVal *, IntKeyExtractor> mTrie;
-
-        {
-            // Load
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, LOAD_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    IntKeyVal *key;
-                    posix_memalign((void **)&key, 64, sizeof(IntKeyVal));
-                    key->key = init_keys[i]; key->value = init_keys[i];
-                    Dummy::clflush((char *)key, sizeof(IntKeyVal), true, true);
-                    if (!(mTrie.insert(key))) {
-                        fprintf(stderr, "[HOT] load insert fail\n");
-                        exit(1);
-                    }
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: load, %f ,ops/us\n", (LOAD_SIZE * 1.0) / duration.count());
-        }
-
-        {
-            // Run
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, RUN_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    if (ops[i] == OP_INSERT) {
-                        IntKeyVal *key;
-                        posix_memalign((void **)&key, 64, sizeof(IntKeyVal));
-                        key->key = keys[i]; key->value = keys[i];
-                        Dummy::clflush((char *)key, sizeof(IntKeyVal), true, true);
-                        if (!(mTrie.insert(key))) {
-                            fprintf(stderr, "[HOT] run insert fail\n");
-                            exit(1);
-                        }
-                    } else if (ops[i] == OP_READ) {
-                        idx::contenthelpers::OptionalValue<IntKeyVal *> result = mTrie.lookup(keys[i]);
-                        if (!result.mIsValid || result.mValue->value != keys[i]) {
-                            printf("mIsValid = %d\n", result.mIsValid);
-                            printf("Return value = %lu, Correct value = %lu\n", result.mValue->value, keys[i]);
-                            exit(1);
-                        }
-                    } else if (ops[i] == OP_SCAN) {
-                        idx::contenthelpers::OptionalValue<IntKeyVal *> result = mTrie.scan(keys[i], ranges[i]);
-                    } else if (ops[i] == OP_UPDATE) {
-                        std::cout << "NOT SUPPORTED CMD!\n";
-                        exit(0);
-                    }
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: run, %f ,ops/us\n", (RUN_SIZE * 1.0) / duration.count());
-        }
-#endif
     } else if (index_type == TYPE_BWTREE) {
-        auto t = new BwTree<uint64_t, uint64_t, KeyComparator, KeyEqualityChecker>{true, KeyComparator{1}, KeyEqualityChecker{1}};
-        t->UpdateThreadLocal(1);
-        t->AssignGCID(0);
-        std::atomic<int> next_thread_id;
-
-        {
-            // Load
-            auto starttime = std::chrono::system_clock::now();
-            next_thread_id.store(0);
-            t->UpdateThreadLocal(num_thread);
-            auto func = [&]() {
-                int thread_id = next_thread_id.fetch_add(1);
-                uint64_t start_key = LOAD_SIZE / num_thread * (uint64_t)thread_id;
-                uint64_t end_key = start_key + LOAD_SIZE / num_thread;
-
-                t->AssignGCID(thread_id);
-                for (uint64_t i = start_key; i < end_key; i++) {
-                    t->Insert(init_keys[i], init_keys[i]);
-                }
-                t->UnregisterThread(thread_id);
-            };
-
-            std::vector<std::thread> thread_group;
-
-            for (int i = 0; i < num_thread; i++)
-                thread_group.push_back(std::thread{func});
-
-            for (int i = 0; i < num_thread; i++)
-                thread_group[i].join();
-            t->UpdateThreadLocal(1);
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: load, %f ,ops/us\n", (LOAD_SIZE * 1.0) / duration.count());
-        }
-
-        {
-            // Run
-            auto starttime = std::chrono::system_clock::now();
-            next_thread_id.store(0);
-            t->UpdateThreadLocal(num_thread);
-            auto func = [&]() {
-                std::vector<uint64_t> v{};
-                v.reserve(1);
-                int thread_id = next_thread_id.fetch_add(1);
-                uint64_t start_key = RUN_SIZE / num_thread * (uint64_t)thread_id;
-                uint64_t end_key = start_key + RUN_SIZE / num_thread;
-
-                t->AssignGCID(thread_id);
-                for (uint64_t i = start_key; i < end_key; i++) {
-                    if (ops[i] == OP_INSERT) {
-                        t->Insert(keys[i], keys[i]);
-                    } else if (ops[i] == OP_READ) {
-                        v.clear();
-                        t->GetValue(keys[i], v);
-                        if (v[0] != keys[i]) {
-                            std::cout << "[BWTREE] wrong key read: " << v[0] << " expected:" << keys[i] << std::endl;
-                        }
-                    } else if (ops[i] == OP_SCAN) {
-                        uint64_t buf[200];
-                        auto it = t->Begin(keys[i]);
-
-                        int resultsFound = 0;
-                        while (it.IsEnd() != true && resultsFound != ranges[i]) {
-                            buf[resultsFound] = it->second;
-                            resultsFound++;
-                            it++;
-                        }
-                    } else if (ops[i] == OP_UPDATE) {
-                        std::cout << "NOT SUPPORTED CMD!\n";
-                        exit(0);
-                    }
-                }
-                t->UnregisterThread(thread_id);
-            };
-
-            std::vector<std::thread> thread_group;
-
-            for (int i = 0; i < num_thread; i++)
-                thread_group.push_back(std::thread{func});
-
-            for (int i = 0; i < num_thread; i++)
-                thread_group[i].join();
-            t->UpdateThreadLocal(1);
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: run, %f ,ops/us\n", (RUN_SIZE * 1.0) / duration.count());
-        }
     } else if (index_type == TYPE_MASSTREE) {
-        masstree::masstree *tree = new masstree::masstree();
-
-        {
-            // Load
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, LOAD_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                auto t = tree->getThreadInfo();
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    tree->put(init_keys[i], &init_keys[i], t);
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: load, %f ,ops/us\n", (LOAD_SIZE * 1.0) / duration.count());
-        }
-
-        {
-            // Run
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, RUN_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                auto t = tree->getThreadInfo();
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    if (ops[i] == OP_INSERT) {
-                        tree->put(keys[i], &keys[i], t);
-                    } else if (ops[i] == OP_READ) {
-                        uint64_t *ret = reinterpret_cast<uint64_t *> (tree->get(keys[i], t));
-                        if (ap == UNIFORM && *ret != keys[i]) {
-                            printf("[MASS] search key = %lu, search value = %lu\n", keys[i], *ret);
-                            exit(1);
-                        }
-                    } else if (ops[i] == OP_SCAN) {
-                        uint64_t buf[200];
-                        int ret = tree->scan(keys[i], ranges[i], buf, t);
-                    } else if (ops[i] == OP_DELETE) {
-                        tree->del(keys[i], t);
-                    } else if (ops[i] == OP_UPDATE) {
-                        tree->put(keys[i], &keys[i], t);
-                    }
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: run, %f ,ops/us\n", (RUN_SIZE * 1.0) / duration.count());
-        }
     } else if (index_type == TYPE_CLHT) {
-        clht_t *hashtable = clht_create(512);
+        clht_t *hashtable = clht_create(8);
 
         barrier_init(&barrier, num_thread);
 
@@ -1025,70 +269,52 @@ void ycsb_load_run_randint(int index_type, int wl, int kt, int ap, int num_threa
 
         std::atomic<int> next_thread_id;
 
-        {
-            // Load
-            auto starttime = std::chrono::system_clock::now();
-            next_thread_id.store(0);
-            auto func = [&]() {
-                int thread_id = next_thread_id.fetch_add(1);
-                tds[thread_id].id = thread_id;
-                tds[thread_id].ht = hashtable;
-
-                uint64_t start_key = LOAD_SIZE / num_thread * (uint64_t)thread_id;
-                uint64_t end_key = start_key + LOAD_SIZE / num_thread;
+        afl_testcase_buf = __AFL_FUZZ_TESTCASE_BUF;
+        afl_testcase_len = __AFL_FUZZ_TESTCASE_LEN;
 
-                clht_gc_thread_init(tds[thread_id].ht, tds[thread_id].id);
-                barrier_cross(&barrier);
-
-                for (uint64_t i = start_key; i < end_key; i++) {
-                    clht_put(tds[thread_id].ht, init_keys[i], init_keys[i]);
-                }
-            };
-
-            std::vector<std::thread> thread_group;
-
-            for (int i = 0; i < num_thread; i++)
-                thread_group.push_back(std::thread{func});
-
-            for (int i = 0; i < num_thread; i++)
-                thread_group[i].join();
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: load, %f ,ops/us\n", (LOAD_SIZE * 1.0) / duration.count());
+        for (i = 0; i < num_thread; ++i) {
+            if (i == 0) {
+                tok = strtok((char *)afl_testcase_buf, "\t");
+            } else {
+                tok = strtok(NULL, "\t");
+            }
+    
+            if (tok == NULL) {
+                cmd_streams.emplace_back(string());
+            } else {
+                cmd_streams.emplace_back(tok);
+            }
         }
 
-        barrier.crossing = 0;
-
         {
-            // Run
-            auto starttime = std::chrono::system_clock::now();
             next_thread_id.store(0);
             auto func = [&]() {
                 int thread_id = next_thread_id.fetch_add(1);
+                uint64_t k, v;
+                char op;
+
                 tds[thread_id].id = thread_id;
                 tds[thread_id].ht = hashtable;
 
-                uint64_t start_key = RUN_SIZE / num_thread * (uint64_t)thread_id;
-                uint64_t end_key = start_key + RUN_SIZE / num_thread;
-
                 clht_gc_thread_init(tds[thread_id].ht, tds[thread_id].id);
                 barrier_cross(&barrier);
 
-                for (uint64_t i = start_key; i < end_key; i++) {
-                    if (ops[i] == OP_INSERT) {
-                        clht_put(tds[thread_id].ht, keys[i], keys[i]);
-                    } else if (ops[i] == OP_READ) {
-                        uintptr_t val = clht_get(tds[thread_id].ht->ht, keys[i]);
-                        if (val != keys[i]) {
-                            std::cout << "[CLHT] wrong key read: " << val << "expected: " << keys[i] << std::endl;
-                            exit(1);
-                        }
-                    } else if (ops[i] == OP_SCAN) {
-                        std::cout << "NOT SUPPORTED CMD!\n";
-                        exit(0);
-                    } else if (ops[i] == OP_UPDATE) {
-                        std::cout << "NOT SUPPORTED CMD!\n";
-                        exit(0);
+                while (cmd_streams[thread_id] >> op) {
+                    if (op == 'i') {
+                        cmd_streams[thread_id] >> std::hex >> k >> v;
+                        clht_put(tds[thread_id].ht, k, v);
+                    } else if (op == 'd') {
+                        cmd_streams[thread_id] >> std::hex >> k;
+                        clht_remove(tds[thread_id].ht, k);
+                    } else if (op == 'g') {
+                        cmd_streams[thread_id] >> std::hex >> k;
+                        clht_get(tds[thread_id].ht, k);
+                    } else if (op == 'u') {
+                        cmd_streams[thread_id] >> std::hex >> k >> v;
+                        clht_update(tds[thread_id].ht, k, v);
+                    } else {
+                        std::cerr << "Unsupported cmd\n";
+                        abort();
                     }
                 }
             };
@@ -1100,201 +326,24 @@ void ycsb_load_run_randint(int index_type, int wl, int kt, int ap, int num_threa
 
             for (int i = 0; i < num_thread; i++)
                 thread_group[i].join();
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: run, %f ,ops/us\n", (RUN_SIZE * 1.0) / duration.count());
         }
-        clht_gc_destroy(hashtable);
+        // clht_gc_destroy(hashtable);
     } else if (index_type == TYPE_FASTFAIR) {
-        fastfair::btree *bt = new fastfair::btree();
-
-        {
-            // Load
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, LOAD_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    bt->btree_insert(init_keys[i], (char *) &init_keys[i]);
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: load, %f ,ops/us\n", (LOAD_SIZE * 1.0) / duration.count());
-        }
-
-        {
-            // Run
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, RUN_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    if (ops[i] == OP_INSERT) {
-                        bt->btree_insert(keys[i], (char *) &keys[i]);
-                    } else if (ops[i] == OP_READ) {
-                        uint64_t *ret = reinterpret_cast<uint64_t *>(bt->btree_search(keys[i]));
-                        if (ret == NULL) {
-                            //printf("NULL is found\n");
-                        } else if (*ret != keys[i]) {
-                            //printf("[FASTFAIR] wrong value is returned: <expected> %lu\n", keys[i]);
-                            //exit(1);
-                        }
-                    } else if (ops[i] == OP_SCAN) {
-                        uint64_t buf[200];
-                        int resultsFound = 0;
-                        bt->btree_search_range (keys[i], UINT64_MAX, buf, ranges[i], resultsFound);
-                    } else if (ops[i] == OP_UPDATE) {
-                        std::cout << "NOT SUPPORTED CMD!\n";
-                        exit(0);
-                    }
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: run, %f ,ops/us\n", (RUN_SIZE * 1.0) / duration.count());
-        }
     } else if (index_type == TYPE_LEVELHASH) {
-        Hash *table = new LevelHashing(10);
-
-        {
-            // Load
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, LOAD_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    table->Insert(init_keys[i], reinterpret_cast<const char*>(&init_keys[i]));
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: load, %f ,ops/us\n", (LOAD_SIZE * 1.0) / duration.count());
-        }
-
-        {
-            // Run
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, RUN_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    if (ops[i] == OP_INSERT) {
-                        table->Insert(keys[i], reinterpret_cast<const char*>(&keys[i]));
-                    } else if (ops[i] == OP_READ) {
-                        auto val = table->Get(keys[i]);
-                        if (val == NONE) {
-                            std::cout << "[Level Hashing] wrong key read: " << *(uint64_t *)val << " expected: " << keys[i] << std::endl;
-                            exit(1);
-                        }
-                    } else if (ops[i] == OP_SCAN) {
-                        std::cout << "NOT SUPPORTED CMD!\n";
-                        exit(0);
-                    } else if (ops[i] == OP_UPDATE) {
-                        std::cout << "NOT SUPPORTED CMD!\n";
-                        exit(0);
-                    }
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: run, %f ,ops/us\n", (RUN_SIZE * 1.0) / duration.count());
-        }
     } else if (index_type == TYPE_CCEH) {
-        Hash *table = new CCEH(2);
-
-        {
-            // Load
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, LOAD_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    table->Insert(init_keys[i], reinterpret_cast<const char*>(&init_keys[i]));
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: load, %f ,ops/us\n", (LOAD_SIZE * 1.0) / duration.count());
-        }
-
-        {
-            // Run
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, RUN_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    if (ops[i] == OP_INSERT) {
-                        table->Insert(keys[i], reinterpret_cast<const char*>(&keys[i]));
-                    } else if (ops[i] == OP_READ) {
-                        uint64_t *val = reinterpret_cast<uint64_t *>(const_cast<char *>(table->Get(keys[i])));
-                        if (val == NULL) {
-                            //std::cout << "[CCEH] wrong value is read <expected:> " << keys[i] << std::endl;
-                            //exit(1);
-                        }
-                    } else if (ops[i] == OP_SCAN) {
-                        std::cout << "NOT SUPPORTED CMD!\n";
-                        exit(0);
-                    } else if (ops[i] == OP_UPDATE) {
-                        std::cout << "NOT SUPPORTED CMD!\n";
-                        exit(0);
-                    }
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: run, %f ,ops/us\n", (RUN_SIZE * 1.0) / duration.count());
-        }
     } else if (index_type == TYPE_WOART) {
-#ifndef STRING_TYPE
-        woart_tree *t = (woart_tree *)malloc(sizeof(woart_tree));
-        woart_tree_init(t);
-
-        {
-            // Load
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, LOAD_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    woart_insert(t, init_keys[i], sizeof(uint64_t), &init_keys[i]);
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: load, %f ,ops/us\n", (LOAD_SIZE * 1.0) / duration.count());
-        }
-
-        {
-            // Run
-            auto starttime = std::chrono::system_clock::now();
-            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, RUN_SIZE), [&](const tbb::blocked_range<uint64_t> &scope) {
-                for (uint64_t i = scope.begin(); i != scope.end(); i++) {
-                    if (ops[i] == OP_INSERT) {
-                        woart_insert(t, keys[i], sizeof(uint64_t), &keys[i]);
-                    } else if (ops[i] == OP_READ) {
-                        uint64_t *ret = reinterpret_cast<uint64_t *> (woart_search(t, keys[i], sizeof(uint64_t)));
-                        if (*ret != keys[i]) {
-                            printf("[WOART] expected = %lu, search value = %lu\n", keys[i], *ret);
-                            exit(1);
-                        }
-                    } else if (ops[i] == OP_SCAN) {
-                        unsigned long buf[200];
-                        woart_scan(t, keys[i], ranges[i], buf);
-                    } else if (ops[i] == OP_UPDATE) {
-                        std::cout << "NOT SUPPORTED CMD!\n";
-                        exit(0);
-                    }
-                }
-            });
-            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
-                    std::chrono::system_clock::now() - starttime);
-            printf("Throughput: run, %f ,ops/us\n", (RUN_SIZE * 1.0) / duration.count());
-        }
-#endif
     }
 }
 
 int main(int argc, char **argv) {
-    if (argc != 6) {
-        std::cout << "Usage: ./ycsb [index type] [ycsb workload type] [key distribution] [access pattern] [number of threads]\n";
-        std::cout << "1. index type: art hot bwtree masstree clht\n";
+    if (argc != 3) {
+        std::cout << "Usage: ./ycsb [index type] [number of threads]\n";
+        std::cout << "   index type: art hot bwtree masstree clht\n";
         std::cout << "               fastfair levelhash cceh woart\n";
-        std::cout << "2. ycsb workload type: a, b, c, e\n";
-        std::cout << "3. key distribution: randint, string\n";
-        std::cout << "4. access pattern: uniform, zipfian\n";
-        std::cout << "5. number of threads (integer)\n";
         return 1;
     }
 
-    printf("%s, workload%s, %s, %s, threads %s\n", argv[1], argv[2], argv[3], argv[4], argv[5]);
+    printf("%s, threads %s\n", argv[1], argv[2]);
 
     int index_type;
     if (strcmp(argv[1], "art") == 0)
@@ -1324,80 +373,10 @@ int main(int argc, char **argv) {
         exit(1);
     }
 
-    int wl;
-    if (strcmp(argv[2], "a") == 0) {
-        wl = WORKLOAD_A;
-    } else if (strcmp(argv[2], "b") == 0) {
-        wl = WORKLOAD_B;
-    } else if (strcmp(argv[2], "c") == 0) {
-        wl = WORKLOAD_C;
-    } else if (strcmp(argv[2], "d") == 0) {
-        wl = WORKLOAD_D;
-    } else if (strcmp(argv[2], "e") == 0) {
-        wl = WORKLOAD_E;
-    } else {
-        fprintf(stderr, "Unknown workload: %s\n", argv[2]);
-        exit(1);
-    }
-
-    int kt;
-    if (strcmp(argv[3], "randint") == 0) {
-        kt = RANDINT_KEY;
-    } else if (strcmp(argv[3], "string") == 0) {
-        kt = STRING_KEY;
-    } else {
-        fprintf(stderr, "Unknown key type: %s\n", argv[3]);
-        exit(1);
-    }
-
-    int ap;
-    if (strcmp(argv[4], "uniform") == 0) {
-        ap = UNIFORM;
-    } else if (strcmp(argv[4], "zipfian") == 0) {
-        ap = ZIPFIAN;
-    } else {
-        fprintf(stderr, "Unknown access pattern: %s\n", argv[4]);
-        exit(1);
-    }
-
-    int num_thread = atoi(argv[5]);
+    int num_thread = atoi(argv[2]);
     tbb::task_scheduler_init init(num_thread);
 
-    if (kt != STRING_KEY) {
-        std::vector<uint64_t> init_keys;
-        std::vector<uint64_t> keys;
-        std::vector<int> ranges;
-        std::vector<int> ops;
-
-        init_keys.reserve(LOAD_SIZE);
-        keys.reserve(RUN_SIZE);
-        ranges.reserve(RUN_SIZE);
-        ops.reserve(RUN_SIZE);
-
-        memset(&init_keys[0], 0x00, LOAD_SIZE * sizeof(uint64_t));
-        memset(&keys[0], 0x00, RUN_SIZE * sizeof(uint64_t));
-        memset(&ranges[0], 0x00, RUN_SIZE * sizeof(int));
-        memset(&ops[0], 0x00, RUN_SIZE * sizeof(int));
-
-        ycsb_load_run_randint(index_type, wl, kt, ap, num_thread, init_keys, keys, ranges, ops);
-    } else {
-        std::vector<Key *> init_keys;
-        std::vector<Key *> keys;
-        std::vector<int> ranges;
-        std::vector<int> ops;
-
-        init_keys.reserve(LOAD_SIZE);
-        keys.reserve(RUN_SIZE);
-        ranges.reserve(RUN_SIZE);
-        ops.reserve(RUN_SIZE);
-
-        memset(&init_keys[0], 0x00, LOAD_SIZE * sizeof(Key *));
-        memset(&keys[0], 0x00, RUN_SIZE * sizeof(Key *));
-        memset(&ranges[0], 0x00, RUN_SIZE * sizeof(int));
-        memset(&ops[0], 0x00, RUN_SIZE * sizeof(int));
-
-        ycsb_load_run_string(index_type, wl, kt, ap, num_thread, init_keys, keys, ranges, ops);
-    }
+    ycsb_load_run_randint(index_type, num_thread);
 
     return 0;
 }
