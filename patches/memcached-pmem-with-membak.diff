diff --git a/Makefile.am b/Makefile.am
index 712aa45..89a46e5 100755
--- a/Makefile.am
+++ b/Makefile.am
@@ -111,6 +111,14 @@ EXTRA_DIST = doc scripts t memcached.spec memcached_dtrace.d version.m4 README.m
 
 MOSTLYCLEANFILES = *.gcov *.gcno *.gcda *.tcov
 
+PMDK_DIR = /home/vagrant/pmdk
+PMDK_INSTALL_DIR = $(PMDK_DIR)/install
+PMDK_FLAGS = -I$(PMDK_INSTALL_DIR)/include -mclflushopt -mclwb
+PMDK_LD_FLAGS = -L$(PMDK_INSTALL_DIR)/lib/pmdk_debug -lpmem -lpmemobj
+
+CFLAGS += $(PMDK_FLAGS)
+LDFLAGS += $(PMDK_LD_FLAGS)
+
 test:	memcached-debug sizes testapp
 	$(srcdir)/sizes
 	$(srcdir)/testapp
diff --git a/configure.ac b/configure.ac
index d7e763b..1b00e64 100755
--- a/configure.ac
+++ b/configure.ac
@@ -630,12 +630,12 @@ dnl to detect the function ;-)
 if test "$ICC" = "yes"
 then
    dnl ICC trying to be gcc.
-   CFLAGS="$CFLAGS -diag-disable 187 -Wall -Werror"
+   CFLAGS="$CFLAGS -diag-disable 187 -Wall"
    AC_DEFINE([_GNU_SOURCE],[1],[find sigignore on Linux])
 elif test "$GCC" = "yes"
 then
   GCC_VERSION=`$CC -dumpversion`
-  CFLAGS="$CFLAGS -Wall -Werror -pedantic -Wmissing-prototypes -Wmissing-declarations -Wredundant-decls"
+  CFLAGS="$CFLAGS -Wall -pedantic -Wmissing-prototypes -Wmissing-declarations -Wredundant-decls"
   case $GCC_VERSION in
     4.4.*)
     CFLAGS="$CFLAGS -fno-strict-aliasing"
diff --git a/hash.c b/hash.c
index a0c3036..b5ff28a 100755
--- a/hash.c
+++ b/hash.c
@@ -4,6 +4,8 @@
 #include "jenkins_hash.h"
 #include "murmur3_hash.h"
 
+hash_func hash;
+
 int hash_init(enum hashfunc_type type) {
     switch(type) {
         case JENKINS_HASH:
diff --git a/hash.h b/hash.h
index 059d1e2..3b2a984 100755
--- a/hash.h
+++ b/hash.h
@@ -2,7 +2,7 @@
 #define    HASH_H
 
 typedef uint32_t (*hash_func)(const void *key, size_t length);
-hash_func hash;
+extern hash_func hash;
 
 enum hashfunc_type {
     JENKINS_HASH=0, MURMUR3_HASH
diff --git a/memcached.c b/memcached.c
index f66a738..7802852 100755
--- a/memcached.c
+++ b/memcached.c
@@ -60,6 +60,7 @@
 #include <limits.h>
 #include <sysexits.h>
 #include <stddef.h>
+#include <semaphore.h>
 
 #ifdef HAVE_GETOPT_LONG
 #include <getopt.h>
@@ -6473,7 +6474,11 @@ static void remove_pidfile(const char *pid_file) {
 }
 
 static void sig_handler(const int sig) {
-    printf("Signal handled: %s.\n", strsignal(sig));
+    fprintf(stderr, "Signal handled: %s.\n", strsignal(sig));
+    if (event_base_loopbreak(main_base) == -1) {
+        perror("event_base_loopbreak failed");
+        exit(EXIT_FAILURE);
+    }
     exit(EXIT_SUCCESS);
 }
 
@@ -6592,6 +6597,94 @@ static bool _parse_slab_sizes(char *s, uint32_t *slab_sizes) {
     return true;
 }
 
+#ifndef __AFL_FUZZ_TESTCASE_LEN
+  ssize_t fuzz_len;
+  #define __AFL_FUZZ_TESTCASE_LEN fuzz_len
+  unsigned char fuzz_buf[1024000];
+  #define __AFL_FUZZ_TESTCASE_BUF fuzz_buf
+  #define __AFL_FUZZ_INIT()
+  #define __AFL_INIT() ((fuzz_len = read(0, fuzz_buf, sizeof(fuzz_buf))) > 0 ? 1 : 0)
+#endif
+
+__AFL_FUZZ_INIT()
+
+typedef struct pthread_args {
+    const char *buf;
+    ssize_t len;
+} pthread_args;
+
+sem_t sema_init;
+
+extern void *membak, *addr;
+
+static void *connect_server(void *args)
+{
+    struct addrinfo *ai = 0;
+    struct addrinfo hints = { .ai_family = AF_UNSPEC,
+                              .ai_protocol = IPPROTO_TCP,
+                              .ai_socktype = SOCK_STREAM };
+    char service[NI_MAXSERV];
+    int error, sock = -1;
+    off_t offset = 0;
+    const char* ptr = ((pthread_args *)args)->buf;
+    size_t len = ((pthread_args *)args)->len;
+
+    sem_wait(&sema_init);
+
+    (void)snprintf(service, NI_MAXSERV, "%d", settings.port);
+    if ((error = getaddrinfo("127.0.0.1", service, &hints, &ai)) != 0) {
+       if (error != EAI_SYSTEM) {
+          fprintf(stderr, "getaddrinfo(): %s\n", gai_strerror(error));
+       } else {
+          perror("getaddrinfo()");
+       }
+    }
+
+    if (ai != NULL) {
+       if ((sock = socket(ai->ai_family, ai->ai_socktype,
+                          ai->ai_protocol)) != -1) {
+          if (connect(sock, ai->ai_addr, ai->ai_addrlen) == -1) {
+             fprintf(stderr, "Failed to connect socket: %s\n",
+                     strerror(errno));
+             close(sock);
+             sock = -1;
+          }
+       } else {
+          fprintf(stderr, "Failed to create socket: %s\n", strerror(errno));
+       }
+
+       freeaddrinfo(ai);
+    }
+
+    if (sock == -1) {
+        return NULL;
+    }
+
+    do {
+        ssize_t nw = write(sock, ptr + offset, len - offset);
+        if (nw == -1) {
+            if (errno != EINTR) {
+                fprintf(stderr, "Failed to write: %s\n", strerror(errno));
+                abort();
+            }
+        } else {
+            offset += nw;
+        }
+    } while (offset < len);
+
+    char quit_cmd[] = "quit\r\n";
+    if (write(sock, quit_cmd, sizeof(quit_cmd)) == -1) {
+        perror("Failed to write quit");
+        abort();
+    }
+
+    char buffer[4069];
+    while (recv(sock, buffer, sizeof(buffer), MSG_WAITALL) != 0);
+
+    close(sock);
+    return NULL;
+}
+
 int main (int argc, char **argv) {
     int c;
     bool lock_memory = false;
@@ -6764,6 +6857,10 @@ int main (int argc, char **argv) {
         NULL
     };
 
+    pid_t child_pid;
+    unsigned char *afl_testcase_buf;
+    ssize_t afl_testcase_len;
+
     if (!sanitycheck()) {
         return EX_OSERR;
     }
@@ -7812,6 +7909,18 @@ fprintf(stderr, "pslab_size=%ld", pslab_size);
         slabs_update_policy();
     }
 #endif
+
+    __AFL_INIT();
+    afl_testcase_buf = __AFL_FUZZ_TESTCASE_BUF;
+    afl_testcase_len = __AFL_FUZZ_TESTCASE_LEN;
+
+    memcpy(addr, membak, settings.pslab_size);
+
+    char cmd[128] = {};
+    sprintf(cmd, "kill -9 `lsof -t -i:%d` 2> /dev/null", settings.port);
+    // fprintf(stderr, "cmd: %s\n", cmd);
+    system(cmd);
+
 #ifdef EXTSTORE
     if (storage_file) {
         enum extstore_res eres;
@@ -7970,6 +8079,52 @@ fprintf(stderr, "pslab_size=%ld", pslab_size);
     /* Initialize the uriencode lookup table. */
     uriencode_init();
 
+    child_pid = fork();
+
+    if (child_pid < 0) {
+        perror("fork failed");
+        exit(EXIT_FAILURE);
+    }
+
+    if (!child_pid) {
+        pthread_args args[settings.num_threads];
+        pthread_t tid[settings.num_threads];
+        int i, ret;
+
+        sem_init(&sema_init, 0, 0);
+
+        if (afl_testcase_len < 0) {
+            perror("read failed");
+            exit(EXIT_FAILURE);
+        }
+
+        for (i = 0; i < settings.num_threads; ++i) {
+            if (i == 0) {
+                args[i].buf = strtok((char *)afl_testcase_buf, "\t");
+            } else {
+                args[i].buf = strtok(NULL, "\t");
+            }
+
+            args[i].len = args[i].buf == NULL ? 0 : strlen(args[i].buf);
+
+            if ((ret = pthread_create(&tid[i], NULL, connect_server, &args[i])) != 0) {
+                fprintf(stderr, "Can't create thread: %s\n", strerror(ret));
+                exit(EXIT_FAILURE);
+            }
+        }
+
+        for (i = 0; i < settings.num_threads; ++i) {
+            sem_post(&sema_init);
+        }
+
+        for (i = 0; i < settings.num_threads; ++i) {
+            pthread_join(tid[i], NULL);
+        }
+
+        kill(getppid(), SIGINT);
+        return EXIT_SUCCESS;
+    }
+
     /* enter the event loop */
     if (event_base_loop(main_base, 0) != 0) {
         retval = EXIT_FAILURE;
diff --git a/pslab.c b/pslab.c
index 912c97f..3382a2b 100755
--- a/pslab.c
+++ b/pslab.c
@@ -313,6 +313,8 @@ int pslab_pre_recover(char *name, uint32_t *slab_sizes, int slab_max,
 }
 
 bool pslab_force;
+const uint32_t pool_hdr_size = 0x1000;
+void *membak = NULL, *addr = NULL;
 
 int pslab_create(char *pool_name, uint32_t pool_size, uint32_t slab_page_size,
         uint32_t *slabclass_sizes, int slabclass_num) {
@@ -333,6 +335,11 @@ int pslab_create(char *pool_name, uint32_t pool_size, uint32_t slab_page_size,
         return -1;
     }
 
+    // memcached membak
+    addr = (void *)pslab_pool;
+    membak = malloc(pool_size);
+    memcpy(membak, addr, pool_size);
+
     length = (sizeof (pslab_pool_t) + sizeof (pslab_pool->slabclass_sizes[0])
         * slabclass_num + 7) & PSLAB_ALIGN_MASK;
     pmem_memset_nodrain(pslab_pool, 0, length);
